---
layout: post
category : ç®—æ³•
title: 'ç¼–ç¨‹è¯­è¨€çš„sortæ–¹æ³•å®ç°'
tagline: ""
tags : [ç®—æ³•]
---

## sortå®ç°

- PHP
- JAVA
- Python
- Golang

<!--break-->

## PHP

ç‰ˆæœ¬ 8.1

å†…éƒ¨å®ç°æœºåˆ¶ä¸ºï¼šå¿«é€Ÿæ’åºã€æ’å…¥æ’åº

- å°äº 6 ä¸ªå…ƒç´ æ—¶ï¼Œç›´æ¥`if else`å¯¹æ¯”æ’åº
- ç­‰äº 6 ä¸ªå…ƒç´ æ—¶ï¼Œé‡‡ç”¨ç›´æ¥`æ’å…¥æ’åº`ï¼Œé¿å…å¿«æ’çš„ç©ºé—´æ¶ˆè€—
- å¤§äº 6 åˆ° å°äºç­‰äº 16 ä¸ªå…ƒç´ æ—¶ï¼Œé‡‡ç”¨siz2 `æ’å…¥æ’åº`
- å¤§äº 16 ä¸ªå…ƒç´ ï¼Œå¿«é€Ÿæ’åº

å¿«æ’ï¼Œåœ¨æ•°ç»„ä¸­é€‰ä¸€ä¸ªå…ƒç´ ä½œä¸ºä¸­å¿ƒå…ƒç´ ï¼ŒæŠŠæ•°ç»„å…ƒç´ åˆ’åˆ†ä¸ºå°äºä¸­å¿ƒå…ƒç´ çš„é›†åˆä»¥åŠå¤§äºä¸­å¿ƒå…ƒç´ çš„é›†åˆï¼Œä¸¤ä¸ªé›†åˆæ”¾åˆ°ä¸­å¿ƒå…ƒç´ çš„ä¸¤è¾¹ã€‚ç„¶åå†å¯¹ä¸¤ä¸ªé›†åˆåˆ†åˆ«åˆ’åˆ†ï¼Œä¸€ç›´åˆ’åˆ†åˆ°å…ƒç´ ä¸ªæ•°ä¸º 1 æˆ– 0 çš„æ—¶å€™æ‰åœä¸‹ã€‚

å·¦å³æŒ‡é’ˆæ³•

1. é€‰å–ä¸€ä¸ªå…³é”®å­—(key)ä½œä¸ºæ¢è½´
2. è®¾ç½®ä¸¤ä¸ªå˜é‡left = 0;right = N - 1
3. leftä¸€ç›´å‘åèµ°ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªå¤§äºkeyçš„å€¼ï¼Œrightä»åè‡³å‰ï¼Œç›´è‡³æ‰¾åˆ°ä¸€ä¸ªå°äºkeyçš„å€¼ï¼Œç„¶åäº¤æ¢è¿™ä¸¤ä¸ªæ•°
4. é‡å¤ç¬¬ä¸‰æ­¥ï¼Œä¸€ç›´å¾€åæ‰¾ï¼Œç›´åˆ°leftå’Œrightç›¸é‡ï¼Œè¿™æ—¶å°†keyæ”¾ç½®leftçš„ä½ç½®å³å¯
5. å†å¯¹å·¦å³åŒºé—´é‡å¤ç¬¬äºŒæ­¥åˆ°ç¬¬å››æ­¥ï¼Œç›´åˆ°å„åŒºé—´åªæœ‰ä¸€ä¸ªæ•°ï¼ˆé€’å½’ï¼‰

![](/images/202203/sort/quick-sort-01.png)

```
bool sort ( array &$array [, int $sort_flags = SORT_REGULAR ] )
```

ä¼ é€’ä¸€ä¸ªæ•°ç»„ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¹¶ä¸”è¯¥å‚æ•°æ˜¯ä¸€ä¸ªå¼•ç”¨å‚æ•°ï¼Œä¸éœ€è¦è®¾ç½®è¿”å›å€¼ï¼Œæ’åºç»“æœç›´æ¥ä½œç”¨åœ¨æ•°ç»„æœ¬èº«ä¸Šã€‚è¯¥å‡½æ•°é»˜è®¤å¯¹æ•°ç»„å†…æ•°æ®è¿›è¡Œå‡åºæ’åºï¼Œæ”¯æŒå¯¹æ•°å­—å’Œå­—ç¬¦ä¸²è¿›è¡Œæ’åºã€‚

æ’åºç®—æ³•æ¥è‡ª LLVM é¡¹ç›®çš„ libc++ å®ç°

https://github.com/llvm/llvm-project/blob/main/libcxx/include/__algorithm/sort.h#L272

```
template <class _Compare, class _RandomAccessIterator>
void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
```

https://github.com/php/php-src/blob/master/ext/standard/array.c

ext/standard/array.c

```
PHP_FUNCTION(sort)
{
	...
	zend_hash_sort(Z_ARRVAL_P(array), cmp, 1);

	RETURN_TRUE;
}
```

Zend/zend_hash.h

```
ZEND_API void  ZEND_FASTCALL zend_hash_sort_ex(HashTable *ht, sort_func_t sort_func, bucket_compare_func_t compare_func, bool renumber);

#define zend_hash_sort(ht, compare_func, renumber) \
	zend_hash_sort_ex(ht, zend_sort, compare_func, renumber)
```

Zend/zend_hash.c

```
ZEND_API void ZEND_FASTCALL zend_hash_sort_ex(HashTable *ht, sort_func_t sort, bucket_compare_func_t compar, bool renumber)
{
	...

    // sort æ–¹æ³•ï¼Œä¼ çš„ zend_sortï¼Œå®Œæˆæ’åº
	sort((void *)ht->arData, ht->nNumUsed, sizeof(Bucket), (compare_func_t) compar,
			(swap_func_t)(renumber? zend_hash_bucket_renum_swap :
				((HT_FLAGS(ht) & HASH_FLAG_PACKED) ? zend_hash_bucket_packed_swap : zend_hash_bucket_swap)));

	...
}
```

Zend/zend_sort.h

```
ZEND_API void zend_sort(void *base, size_t nmemb, size_t siz, compare_func_t cmp, swap_func_t swp);
ZEND_API void zend_insert_sort(void *base, size_t nmemb, size_t siz, compare_func_t cmp, swap_func_t swp);
```

Zend/zend_sort.c

```
static inline void zend_sort_2(void *a, void *b, compare_func_t cmp, swap_func_t swp) {
	if (cmp(a, b) > 0) {
		swp(a, b);
	}
}

static inline void zend_sort_3(void *a, void *b, void *c, compare_func_t cmp, swap_func_t swp) {
	if (!(cmp(a, b) > 0)) {
		if (!(cmp(b, c) > 0)) {
			return;
		}
		swp(b, c);
		if (cmp(a, b) > 0) {
			swp(a, b);
		}
		return;
	}
	if (!(cmp(c, b) > 0)) {
		swp(a, c);
		return;
	}
	swp(a, b);
	if (cmp(b, c) > 0) {
		swp(b, c);
	}
}

static void zend_sort_4(void *a, void *b, void *c, void *d, compare_func_t cmp, swap_func_t swp) {
	zend_sort_3(a, b, c, cmp, swp);
	if (cmp(c, d) > 0) {
		swp(c, d);
		if (cmp(b, c) > 0) {
			swp(b, c);
			if (cmp(a, b) > 0) {
				swp(a, b);
			}
		}
	}
}

static void zend_sort_5(void *a, void *b, void *c, void *d, void *e, compare_func_t cmp, swap_func_t swp) {
	zend_sort_4(a, b, c, d, cmp, swp);
	if (cmp(d, e) > 0) {
		swp(d, e);
		if (cmp(c, d) > 0) {
			swp(c, d);
			if (cmp(b, c) > 0) {
				swp(b, c);
				if (cmp(a, b) > 0) {
					swp(a, b);
				}
			}
		}
	}
}

ZEND_API void zend_insert_sort(void *base, size_t nmemb, size_t siz, compare_func_t cmp, swap_func_t swp){
	switch (nmemb) {
		case 0:
		case 1:
			break;
		case 2:
			zend_sort_2(base, (char *)base + siz, cmp, swp);
			break;
		case 3:
			zend_sort_3(base, (char *)base + siz, (char *)base + siz + siz, cmp, swp);
			break;
		case 4:
			{
				size_t siz2 = siz + siz;
				zend_sort_4(base, (char *)base + siz, (char *)base + siz2, (char *)base + siz + siz2, cmp, swp);
			}
			break;
		case 5:
			{
				size_t siz2 = siz + siz;
				zend_sort_5(base, (char *)base + siz, (char *)base + siz2, (char *)base + siz + siz2, (char *)base + siz2 + siz2, cmp, swp);
			}
			break;
		default:
			{
				char *i, *j, *k;
				char *start = (char *)base;
				char *end = start + (nmemb * siz);
				size_t siz2= siz + siz;
				char *sentry = start + (6 * siz); // è®¾ç½®ä¸ºç¬¬7ä¸ªå…ƒç´ 

                // ç­‰äº 6 ä¸ªå…ƒç´ æ—¶ï¼Œç›´æ¥æ’å…¥æ’åº
				for (i = start + siz; i < sentry; i += siz) {
                    // j æŒ‡å‘ æœ‰åºåŒº çš„æœ€åä¸€ä¸ªå…ƒç´ 
					j = i - siz;
                    // i > jï¼Œå·²ç»æœ‰åºï¼Œç»§ç»­è€ƒå¯Ÿ æ— åºåŒº ä¸‹ä¸€ä¸ªå…ƒç´ 
					if (!(cmp(j, i) > 0)) {
						continue;
					}
                    // æ¯”è¾ƒæœ‰åºåŒº
					while (j != start) {
						j -= siz;
                        // i > jï¼Œj + siz è·³å‡ºå¾ªç¯
						if (!(cmp(j, i) > 0)) {
							j += siz;
							break;
						}
					}
                    // éå†ï¼Œäº¤æ¢å…ƒç´ ï¼Œä¸ºä»€ä¹ˆæ¯”è¾ƒå’Œäº¤æ¢è¦åˆ†å¼€éå†ä¸¤æ¬¡ï¼Ÿ
					for (k = i; k > j; k -= siz) {
						swp(k, k - siz);
					}
				}

                // å¤§äº 6 ä¸ªå…ƒç´ æ—¶ï¼Œå†ä»å“¨å…µ sentry æŒ‡å‘çš„ç¬¬ 7 ä¸ªå…ƒç´ å¼€å§‹ï¼Œè¿›è¡Œå˜ç§çš„æ’å…¥æ’åºï¼ˆç®€å•æ¥è¯´ï¼Œå°±æ˜¯æŒ‡é’ˆæ¯æ¬¡å¾€å‰ç§»åŠ¨ 2 ä½ï¼Œå»å¯¹æ¯”å¯»æ‰¾å¾…æ’å…ƒç´ æ‰€å±çš„ä½ç½®ï¼Œè€Œæ­£å¸¸æƒ…å†µæ˜¯æ¯æ¬¡ç§»åŠ¨ 1 ä½ï¼‰
				for (i = sentry; i < end; i += siz) {
                    // j æŒ‡å‘ æœ‰åºåŒº çš„æœ€åä¸€ä¸ªå…ƒç´ 
					j = i - siz;
                    // i > jï¼Œå·²ç»æœ‰åºï¼Œç»§ç»­è€ƒå¯Ÿ æ— åºåŒº ä¸‹ä¸€ä¸ªå…ƒç´ 
					if (!(cmp(j, i) > 0)) {
						continue;
					}
                    // æ¯”è¾ƒæœ‰åºåŒºï¼Œä½†æ˜¯ siz -> siz2ï¼Œè¦åˆ¤æ–­ä¸¤æ¬¡
					do {
						j -= siz2;
						if (!(cmp(j, i) > 0)) {
							j += siz;
							if (!(cmp(j, i) > 0)) {
								j += siz;
							}
							break;
						}
                        // è¾¹ç•Œå¤„ç†ï¼Œj æŒ‡å‘ç¬¬ 1 ä¸ªå…ƒç´ ï¼Œi æ¯”ç¬¬ 1 ä¸ªå…ƒç´ è¿˜å°ï¼Œé€€å‡ºå¾ªç¯
						if (j == start) {
							break;
						}
                        // è¾¹ç•Œå¤„ç†ï¼Œj æŒ‡å‘ç¬¬ 2 ä¸ªå…ƒç´ ï¼Œä¸èƒ½å†å¾€å‰ 2 æ­¥ï¼Œåªèƒ½æŒ‡å‘ç¬¬ 1 ä¸ªå…ƒç´ 
						if (j == start + siz) {
							j -= siz;
							if (cmp(i, j) > 0) {
								j += siz;
							}
							break;
						}
					} while (1);
					for (k = i; k > j; k -= siz) {
						swp(k, k - siz);
					}
				}
			}
			break;
	}
}

ZEND_API void zend_sort(void *base, size_t nmemb, size_t siz, compare_func_t cmp, swap_func_t swp)
{
	while (1) {
		if (nmemb <= 16) {
            // æ’å…¥æ’åº
			zend_insert_sort(base, nmemb, siz, cmp, swp);
			return;
		} else {
            // å¿«æ’æŒ‡é’ˆäº¤æ¢æ³•
			char *i, *j;
			char *start = (char *)base;
			char *end = start + (nmemb * siz);
            // å–æ•°ç»„ä¸­é—´å€¼
			size_t offset = (nmemb >> Z_L(1));
            // åˆ†åŒºç‚¹ pivot
			char *pivot = start + (offset * siz);

            // å…ƒç´ ä¸ªæ•° nmemb å³ç§» 10 ä½åä»ä¸ºçœŸï¼Œä¸ªæ•°å¤§äºç­‰äº 1024 æ—¶ï¼Œå°†æ•°ç»„åšä¸¤æ¬¡å¹³åˆ†ã€‚ä¸ªæ•°éå¸¸å¤§æ—¶ï¼Œå¯èƒ½ä¼šå› ä¸ºåˆ’åˆ†åå…ƒç´ ä¸ªæ•°ä»å¤§äº 1024 è€Œå†å–äº”æ•°ä¸­å€¼ã€‚
			if ((nmemb >> Z_L(10))) {
                // å¯¹ offset å†å–ä¸­é—´å€¼
				size_t delta = (offset >> Z_L(1)) * siz;
                // äº”æ•°å–ä¸­æ³•ï¼Œå–ä¸‰ä¸ªä¸­é—´æ•°å’Œä¸¤è¾¹ç¼˜æ•°ï¼Œå–ä¸­é—´å€¼ä½œä¸ºåˆ†åŒºç‚¹ pivot
				zend_sort_5(start, start + delta, pivot, pivot + delta, end - siz, cmp, swp);
			} else {
                // ä¸ªæ•°å°äº 1024 æ—¶ï¼Œå°†æ•°ç»„åšä¸€æ¬¡å¹³åˆ†
                // ä¸‰æ•°å–ä¸­æ³•ï¼Œå–ä¸­é—´æ•°å’Œä¸¤è¾¹ç¼˜æ•°ï¼Œ
				zend_sort_3(start, pivot, end - siz, cmp, swp);
			}
            // å°†åˆ†åŒºç‚¹çš„å€¼ä¸ç¬¬äºŒä¸ªå…ƒç´ çš„å€¼äº’æ¢
			swp(start + siz, pivot);
            // åˆ†åŒºç‚¹ pivot æŒ‡é’ˆæŒ‡å‘ç¬¬äºŒä¸ªå…ƒç´ 
			pivot = start + siz;
            // å¯¹ pivot åé¢çš„å…ƒç´ è¿›è¡Œåˆ†åŒºï¼Œç›®çš„æ˜¯æ‰¾åˆ° pivot åº”è¯¥æ”¾ç½®çš„ä½ç½®ï¼Œä»¥ä¸‹å‡è®¾æ˜¯ä»å°åˆ°å¤§æ’åºï¼Œåˆ™æ¯” pivot å°çš„éƒ½è¦åœ¨å®ƒå·¦è¾¹ï¼Œæ¯” pivot å¤§çš„éƒ½è¦åœ¨å®ƒå³è¾¹
			i = pivot + siz;
			j = end - siz;
			while (1) {
                // æŒ‡é’ˆ i é™¤éå‘ç°æ¯” pivot å¤§çš„å…ƒç´ ï¼Œå¦åˆ™ä¸€ç›´å¾€å³ç§»åŠ¨
				while (cmp(pivot, i) > 0) {
					i += siz;
					if (UNEXPECTED(i == j)) {
						goto done;
					}
				}
                // æŒ‡é’ˆ j å¾€å·¦ç§»åŠ¨ï¼Œç»§ç»­å¯»æ‰¾
				j -= siz;
				if (UNEXPECTED(j == i)) {
					goto done;
				}
                // æŒ‡é’ˆ j é™¤éå‘ç°æ¯” pivot å°çš„å…ƒç´ ï¼Œå¦åˆ™ä¸€ç›´å¾€å·¦ç§»åŠ¨
				while (cmp(j, pivot) > 0) {
					j -= siz;
					if (UNEXPECTED(j == i)) {
						goto done;
					}
				}
                // äº¤æ¢
				swp(i, j);
                // æŒ‡é’ˆ i å¾€å³ç§»åŠ¨ï¼Œç»§ç»­å¯»æ‰¾
				i += siz;
				if (UNEXPECTED(i == j)) {
					goto done;
				}
			}
done:
            // æŒ‡é’ˆ i ä¸ j ç›¸é‡ï¼ŒåŒæ—¶æŒ‡å‘ å³åˆ†åŒº çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚å°†å…ƒç´  i-1ï¼ˆå³å·¦åˆ†åŒºçš„æœ€åä¸€ä¸ªå…ƒç´ ï¼‰çš„å€¼ä¸ pivot å€¼äº’æ¢ï¼Œè‡³æ­¤å®ç° pivot å·¦è¾¹çš„å…ƒç´ éƒ½æ¯”å®ƒå°ï¼Œå³è¾¹çš„éƒ½æ¯”å®ƒå¤§
			swp(pivot, i - siz);
            // æ¯”è¾ƒå·¦å³åˆ†åŒºçš„å…ƒç´ ä¸ªæ•°ï¼Œå…ƒç´ è¾ƒå°‘çš„åˆ†åŒºé€’å½’è°ƒç”¨ zend_sort æ–¹æ³•ï¼Œè¾ƒå¤šçš„åˆ†åŒºç»§ç»­æœ€å¤–å±‚çš„ while å¾ªç¯
			if ((i - siz) - start < end - i) {
				zend_sort(start, (i - start)/siz - 1, siz, cmp, swp);
				base = i;
				nmemb = (end - i)/siz;
			} else {
				zend_sort(i, (end - i)/siz, siz, cmp, swp);
				nmemb = (i - start)/siz - 1;
			}
		}
	}
}
```

## JAVA

ç‰ˆæœ¬ 1.8

å†…éƒ¨å®ç°æœºåˆ¶ä¸ºï¼šTimSortã€æ’å…¥æ’åº

å¿«é€Ÿæ’åºæ˜¯ä¸ç¨³å®šçš„ï¼Œè€ŒTimsortæ˜¯ç¨³å®šçš„ã€‚

```
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    public void sort(Comparator<? super E> c) {
        final int expectedModCount = modCount;
        Arrays.sort((E[]) elementData, 0, size, c);
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }
}

// ifåˆ¤æ–­modCount != expectedModCountï¼ŒexpectedModCountçš„å€¼æ˜¯ä»modCountæ¥åœ¨è¿™æ®µä»£ç ä¸­å¹¶æœªå¯¹ä¸¤ä¸ªå˜é‡è¿›è¡Œä¿®æ”¹ã€‚å¦‚æœæ˜¯å•çº¿ç¨‹ä¸­è¿™çš„ç¡®æ˜¯å†—ä½™çš„ï¼Œä½†æ˜¯ä¸€æ—¦åˆ°äº†å¤šçº¿ç¨‹ä¸­ï¼Œå…¶ä»–çº¿ç¨‹å¯¹è¿™ä¸ªArrayListçš„å®ä¾‹è¿›è¡Œäº†ä¸€ä¸ªadd removeç­‰æ“ä½œï¼Œæ”¹å˜äº†ArrayListæ•°æ®ç»“æ„ã€‚é‚£ä¹ˆmodCountå°±æ”¹å˜äº†ï¼ŒåŒæ ·modCount != expectedModCountä¹Ÿå°±æˆç«‹äº†ï¼Œæœ¬æ¬¡éå†æœ‰è¯¯ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚ArrayListæ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ã€‚åˆ¤æ–­æ“ä½œè¿‡ç¨‹æ˜¯å¦è¢«ä¿®æ”¹ã€‚

public class Arrays {
    // æŒ‡å®šæ•´æ•°å€¼æ•°ç»„çš„æŒ‡å®šèŒƒå›´æŒ‰å‡åºæ’åºã€‚è¦æ’åºçš„èŒƒå›´ä»ç´¢å¼•fromIndex(åŒ…æ‹¬)åˆ°ç´¢å¼•toIndex(ä¸åŒ…æ‹¬)ã€‚é»˜è®¤0åˆ°intæœ€å¤§å€¼ã€‚Comparableæ¥å£ï¼Œæ¯”è¾ƒå™¨æ¥å£ï¼Œè‡ªå®šä¹‰æ¯”è¾ƒã€‚
    public static <T> void sort(T[] a, int fromIndex, int toIndex,
                                Comparator<? super T> c) {
        if (c == null) {
            sort(a, fromIndex, toIndex);
        } else {
            rangeCheck(a.length, fromIndex, toIndex);
            if (LegacyMergeSort.userRequested)
                legacyMergeSort(a, fromIndex, toIndex, c);
            else
                TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);
        }
    }

    // ç®—æ³•æ”¹ç¼–è‡ª TimSort https://svn.python.org/projects/python/trunk/Objects/listsort.txt
    // Timsort æ˜¯Pythonçš„æ ‡å‡†æ’åºç®—æ³•
    public static void sort(Object[] a, int fromIndex, int toIndex) {
        // æ£€æŸ¥fromIndex, toIndexæ˜¯å¦åˆæ³•
        rangeCheck(a.length, fromIndex, toIndex);
        // ç³»ç»Ÿå±æ€§é…ç½®çš„æ—§æ¯”è¾ƒæ–¹æ³•ï¼Œå°†è¢«åˆ é™¤
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, fromIndex, toIndex);
        else
            ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);
    }  
}

class ComparableTimSort {
    static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) {
        assert a != null && lo >= 0 && lo <= hi && hi <= a.length;

        int nRemaining  = hi - lo;
        // åˆ¤æ–­æ•°ç»„é•¿åº¦æ˜¯å¦å°äº2 å¦‚æœæ˜¯åªæœ‰0æˆ–1ï¼Œè¿™ç§æ•°ç»„é€šå¸¸å·²ç»è¢«æ’åº
        if (nRemaining < 2)
            return;  // Arrays of size 0 and 1 are always sorted

        // If array is small, do a "mini-TimSort" with no merges
        // å¦‚æœæ•°ç»„é•¿åº¦å°äºMIN_MERGE(32)åˆ™ä½¿ç”¨äºŒåˆ†æ’å…¥æ’åº
        if (nRemaining < MIN_MERGE) {
            // è·å–éœ€è¦æ¯”è¾ƒçš„èŒƒå›´é•¿åº¦
            int initRunLen = countRunAndMakeAscending(a, lo, hi);
            binarySort(a, lo, hi, lo + initRunLen);
            return;
        }

        /**
         * March over the array once, left to right, finding natural runs,
         * extending short natural runs to minRun elements, and merging runs
         * to maintain stack invariant.
         */
        ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen);
        // TimSort è®¡ç®— minRunçš„å€¼ï¼Œæœ€å°åˆ†ç‰‡é•¿åº¦
        int minRun = minRunLength(nRemaining);
        do {
            // Identify next run
            // è·å¾—ä¸€ä¸ªæœ€é•¿é€’å¢åºåˆ—ï¼Œæœ‰åºç‰‡æ®µé•¿åº¦
            int runLen = countRunAndMakeAscending(a, lo, hi);

            // If run is short, extend to min(minRun, nRemaining)
            // åŸå§‹çš„runå°äºminrunçš„é•¿åº¦ï¼Œç”¨äºŒåˆ†æ’å…¥æ’åºæ‰©å……runï¼Œç›´åˆ°è¾¾åˆ°æ¡ä»¶
            if (runLen < minRun) {
                int force = nRemaining <= minRun ? nRemaining : minRun;
                binarySort(a, lo, lo + force, lo + runLen);
                runLen = force;
            }

            // Push run onto pending-run stack, and maybe merge
            // ç”¨ä¸€ä¸ªæ ˆæ¥ä¿å­˜æ¯ä¸ªrun
            ts.pushRun(lo, runLen);
            // å½’å¹¶æ¥åˆå¹¶å¤šä¸ªrun
            ts.mergeCollapse();

            // Advance to find next run
            // ä¸‹ä¸€åˆ†ç‰‡
            lo += runLen;
            nRemaining -= runLen;
        } while (nRemaining != 0);

        // Merge all remaining runs to complete sort
        assert lo == hi;
        // åˆå¹¶å‰©ä½™çš„run
        ts.mergeForceCollapse();
        assert ts.stackSize == 1;
    }

    // ä¸€æ¬¡è¿è¡Œæ˜¯æœ€é•¿çš„ä¸Šå‡åºåˆ—ï¼Œå…·æœ‰ï¼šA[lo]<=A[lo+1]<=A[lo+2]<=...æˆ–è€…æœ€é•¿çš„é™åºï¼Œç„¶åç¿»è½¬ï¼ša[lo]>a[lo+1]>a[lo+2]>...ï¼Œè¿”å›æœ‰åºç‰‡æ®µé•¿åº¦
    private static int countRunAndMakeAscending(Object[] a, int lo, int hi) {
        assert lo < hi;
        int runHi = lo + 1;
        if (runHi == hi)
            return 1;

        // Find end of run, and reverse range if descending
        if (((Comparable) a[runHi++]).compareTo(a[lo]) < 0) { // Descending
            while (runHi < hi && ((Comparable) a[runHi]).compareTo(a[runHi - 1]) < 0)
                runHi++;
            reverseRange(a, lo, runHi);
        } else {                              // Ascending
            while (runHi < hi && ((Comparable) a[runHi]).compareTo(a[runHi - 1]) >= 0)
                runHi++;
        }

        return runHi - lo;
    }

    // é•¿åº¦å°äº32æ—¶çš„äºŒåˆ†æ’å…¥æ’åºï¼Œå¯¹å°‘é‡å…ƒç´ è¿›è¡Œæ’åºçš„æœ€ä½³æ–¹æ³•ã€‚å®ƒéœ€è¦Oï¼ˆn lognï¼‰æ¯”è¾ƒï¼Œä½†Oï¼ˆn^2ï¼‰æ•°æ®ç§»åŠ¨ï¼ˆæœ€åæƒ…å†µï¼‰ã€‚å¦‚æœæŒ‡å®šèŒƒå›´çš„åˆå§‹éƒ¨åˆ†å·²æ’åºï¼Œåˆ™æ­¤æ–¹æ³•å¯ä»¥åˆ©ç”¨å®ƒï¼ˆæŒ‡æŠŠæ— åºæ’å…¥åˆ°å·²æ’åºï¼‰ï¼šè¯¥æ–¹æ³•å‡å®šç´¢å¼•loï¼ˆåŒ…å«ï¼‰ã€å¼€å§‹å’Œæ’é™¤ä¸­çš„å…ƒç´ å·²æ’åºã€‚å¼€å§‹â€“èŒƒå›´å†…å°šæœªè¢«æ’åºçš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•ï¼ˆlo<=start<=hiï¼‰
    private static void binarySort(Object[] a, int lo, int hi, int start) {
        assert lo <= start && start <= hi;
        if (start == lo)
            start++;
        for ( ; start < hi; start++) {
            Comparable pivot = (Comparable) a[start];

            // Set left (and right) to the index where a[start] (pivot) belongs
            int left = lo;
            int right = start;
            assert left <= right;
            /*
             * Invariants:
             *   pivot >= all in [lo, left).
             *   pivot <  all in [right, start).
             */
            while (left < right) {
                // å³ç§»è¿ç®—ï¼Œç›¸å½“äºmid = (left + right) / 2ï¼Œä½†æ›´å¿«
                int mid = (left + right) >>> 1;
                // è¦æ’åºçš„å€¼å’Œä¸­é—´å€¼æ¯”è¾ƒ
                // a[start] - a[mid] < 0
                if (pivot.compareTo(a[mid]) < 0)
                    right = mid;
                else
                    left = mid + 1;
            }
            // æŠ˜åŠå†æŠ˜åŠ
            assert left == right;

            /*
             * The invariants still hold: pivot >= all in [lo, left) and
             * pivot < all in [left, start), so pivot belongs at left.  Note
             * that if there are elements equal to pivot, left points to the
             * first slot after them -- that's why this sort is stable.
             * Slide elements over to make room for pivot.
             */
            int n = start - left;  // The number of elements to move
            // Switch is just an optimization for arraycopy in default case
            switch (n) {
                case 2:  a[left + 2] = a[left + 1];
                case 1:  a[left + 1] = a[left];
                         break;
                default: System.arraycopy(a, left, a, left + 1, n);
            }
            // æŠŠleftå³è¾¹çš„ç§»åŠ¨ä¸€ä½ï¼Œleftç»™pivot
            a[left] = pivot;
        }
    }

    
    private static final int MIN_MERGE = 32;
    // TimSortæ’åºï¼Œå……åˆ†åˆ©ç”¨äº†å¾…æ’åºæ•°æ®é‡Œé¢ï¼Œæœ‰å¾ˆå¤šå­ä¸²æ˜¯å·²ç»æ’å¥½åºçš„ä¸éœ€è¦å†é‡æ–°æ’åºã€‚
    // å½“æ•°ç»„å…ƒç´ ä¸ªæ•°å¤§äº64æ—¶ï¼Œå¦‚å‰æ‰€è¿°ï¼Œ æˆ‘ä»¬çŸ¥é“å½“ run çš„æ•°ç›®ç­‰äºæˆ–ç•¥å°äº2çš„å¹‚æ—¶ï¼Œåˆå¹¶ä¸¤ä¸ªæ•°ç»„æœ€ä¸ºæœ‰æ•ˆã€‚æ‰€ä»¥ Timsort é€‰æ‹©èŒƒå›´ä¸º [16,32]çš„ minrunï¼Œä½¿å¾—åŸå§‹æ•°ç»„çš„é•¿åº¦n é™¤ä»¥ minrun æ—¶ï¼Œç­‰äºæˆ–ç•¥å°äº2çš„å¹‚ã€‚
    // å…·ä½“è€Œè¨€ï¼Œé€‰æ‹©æ•°ç»„é•¿åº¦çš„äº”ä¸ªæœ€é«˜æ ‡å¿—ä½ï¼Œå¦‚æœå…¶ä½™çš„æ ‡å¿—ä½è¢«è®¾ç½®ï¼Œåˆ™åŠ 1
    // 189ï¼š10111101ï¼Œå–å‰äº”ä¸ªæœ€é«˜æ ‡å¿—ä½ä¸º10111ï¼ˆ23ï¼‰ ï¼ŒåŒæ—¶å1ä½ä¸º1ï¼Œæ‰€ä»¥ minrun ä¸º23+1=24ï¼Œ189/24 = 8
    // 976ï¼š1111010000ï¼Œå–å‰äº”ä¸ªæœ€é«˜æ ‡å¿—ä½ä¸º11110ï¼ˆ30ï¼‰ï¼ŒåŒæ—¶å1ä½ä¸º1ï¼Œæ‰€ä»¥ minrun ä¸º30+1=31ï¼Œ976/31 = 32
    // ä¸ºä»€ä¹ˆéœ€è¦minrunè¿™ä¸ªå€¼æ¥çº¦æŸrunçš„å¤§å°ï¼Œå› ä¸ºè¿™æ ·åšå¯ä»¥ä½¿å¾—runçš„å¤§å°ä¿æŒä¸€ä¸ªå‡è¡¡ï¼Œé¿å…å­˜åœ¨ä¸€ä¸ªå¾ˆçŸ­çš„runå’Œä¸€ä¸ªå¾ˆé•¿çš„runè¿›è¡Œåˆå¹¶ã€‚
    private static int minRunLength(int n) {
        assert n >= 0;
        int r = 0;      // Becomes 1 if any 1 bits are shifted off
        //n >= 32ï¼Œä¸€ç›´ n / 2ï¼Œç›´åˆ°å°äº32ã€‚nä¸º2çš„Nå¹‚ã€‚ n &1ä¹‹åï¼Œnä¸ºå¥‡æ•°åˆ™ä¸º1ï¼Œå¶æ•°ä¸º0ã€‚ rä»£è¡¨æœ€åä¸€æ¬¡ç§»ä½næ—¶ï¼Œnæœ€ä½ä½æ˜¯0è¿˜æ˜¯1ã€‚
        while (n >= MIN_MERGE) {
            r |= (n & 1);
            n >>= 1;
        }
        return n + r;
    }

    private void pushRun(int runBase, int runLen) {
        this.runBase[stackSize] = runBase;
        this.runLen[stackSize] = runLen;
        stackSize++;
    }

    // 1. åªå¯¹ç›¸é‚»çš„åŒºå—merge
    // 2. è‹¥å½“å‰åŒºå—æ•°ä»…ä¸º2ï¼ŒIf X<=Yï¼Œå°†Xå’ŒY merge (Xä¸ºæ ˆåº•)
    // 3. è‹¥å½“å‰åŒºå—æ•°>=3ï¼ŒIf X<=Y+Zï¼Œå°†Xå’ŒY mergeï¼Œç›´åˆ°åŒæ—¶æ»¡è¶³X>Y+Zå’ŒY>Z
    private void mergeCollapse() {
        while (stackSize > 1) {
            int n = stackSize - 2;
            // æ ˆé¡¶çš„3ä¸ªç‰‡æ®µæ¯”è¾ƒï¼ŒrunLen[n-1] <= runLen[n] + runLen[n+1] æˆ–è€… runLen[n] <= runLen[n + 1]ï¼Œåˆå¹¶ä¸¤ä¸ªrun
            if (n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1]) {
                if (runLen[n - 1] < runLen[n + 1])
                    n--;
                mergeAt(n);
            } else if (runLen[n] <= runLen[n + 1]) {
                mergeAt(n);
            } else {
                break; // Invariant is established
            }
        }
    }

    private void mergeAt(int i) {
        assert stackSize >= 2;
        assert i >= 0;
        assert i == stackSize - 2 || i == stackSize - 3;

        int base1 = runBase[i];
        int len1 = runLen[i];
        int base2 = runBase[i + 1];
        int len2 = runLen[i + 1];
        assert len1 > 0 && len2 > 0;
        assert base1 + len1 == base2;

        /*
         * Record the length of the combined runs; if i is the 3rd-last
         * run now, also slide over the last run (which isn't involved
         * in this merge).  The current run (i+1) goes away in any case.
         */
        runLen[i] = len1 + len2; // åˆå¹¶é•¿åº¦
        if (i == stackSize - 3) {
            runBase[i + 1] = runBase[i + 2];
            runLen[i + 1] = runLen[i + 2];
        }
        stackSize--;

        /*
         * æŸ¥æ‰¾åˆ°run2çš„ç¬¬ä¸€ä¸ªå…ƒç´ a[base2]æ’åºåœ¨run1çš„ä½ç½®ï¼Œrun1ä¹‹å‰çš„å…ƒç´ ä¸ç”¨å¤„ç†
         * Find where the first element of run2 goes in run1. Prior elements
         * in run1 can be ignored (because they're already in place).
         */
        int k = gallopRight((Comparable<Object>) a[base2], a, base1, len1, 0);
        assert k >= 0;
        base1 += k;
        len1 -= k; // éœ€è¦å¤„ç†çš„len1 é•¿åº¦
        if (len1 == 0)
            return;

        /*
         * æŸ¥æ‰¾åˆ°run1æœ€åä¸€ä¸ªå…ƒç´ a[base1 + len1 - 1]æ’åºåœ¨run2çš„ä½ç½®ï¼Œrun2ä¹‹åçš„å…ƒç´ ä¸ç”¨å¤„ç†
         * Find where the last element of run1 goes in run2. Subsequent elements
         * in run2 can be ignored (because they're already in place).
         */
        len2 = gallopLeft((Comparable<Object>) a[base1 + len1 - 1], a,
                base2, len2, len2 - 1);
        assert len2 >= 0; // éœ€è¦å¤„ç†len2é•¿åº¦
        if (len2 == 0)
            return;

        // æŠŠmin(len1, len2) å¤åˆ¶åˆ°ä¸´æ—¶arrayï¼Œåˆå¹¶
        // Merge remaining runs, using tmp array with min(len1, len2) elements
        if (len1 <= len2)
            mergeLo(base1, len1, base2, len2);
        else
            mergeHi(base1, len1, base2, len2);
    }

    // å¯»æ‰¾run1çš„æœ€åä¸€ä¸ªå…ƒç´ åº”å½“æ’å…¥run2ä¸­å“ªä¸ªä½ç½®ï¼Œç„¶åå°±å¯ä»¥å¿½ç•¥ä¹‹årun2çš„å…ƒç´ ï¼ˆéƒ½æ¯”run1çš„æœ€åä¸€ä¸ªå…ƒç´ å¤§ï¼‰
    private static int gallopLeft(Comparable<Object> key, Object[] a,
            int base, int len, int hint) {
        assert len > 0 && hint >= 0 && hint < len;

        int lastOfs = 0;
        int ofs = 1;
        if (key.compareTo(a[base + hint]) > 0) {
            // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
            int maxOfs = len - hint;
            while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) > 0) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            // Make offsets relative to base
            lastOfs += hint;
            ofs += hint;
        } else { // key <= a[base + hint]
            // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
            final int maxOfs = hint + 1;
            while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) <= 0) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            // Make offsets relative to base
            int tmp = lastOfs;
            lastOfs = hint - ofs;
            ofs = hint - tmp;
        }
        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;

        /*
         * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
         * to the right of lastOfs but no farther right than ofs.  Do a binary
         * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
         */
        lastOfs++;
        while (lastOfs < ofs) {
            int m = lastOfs + ((ofs - lastOfs) >>> 1);

            if (key.compareTo(a[base + m]) > 0)
                lastOfs = m + 1;  // a[base + m] < key
            else
                ofs = m;          // key <= a[base + m]
        }
        assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]
        return ofs;
    }

    // åœ¨ Galloping mode ä¸­ï¼Œç®—æ³•åœ¨ä¸€ä¸ª run ä¸­æœç´¢å¦ä¸€ä¸ª run çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚é€šè¿‡å°†è¯¥åˆå§‹å…ƒç´ ä¸å¦ä¸€ä¸ª run çš„ç¬¬2 k âˆ’ 1 2k-12kâˆ’1ä¸ªå…ƒç´ ï¼ˆå³1,3,5â€¦ï¼‰è¿›è¡Œæ¯”è¾ƒæ¥å®Œæˆçš„ï¼Œä»¥ä¾¿è·å¾—åˆå§‹å…ƒç´ æ‰€åœ¨çš„å…ƒç´ èŒƒå›´ã€‚è¿™ç¼©çŸ­äº†äºŒåˆ†æŸ¥æ‰¾çš„èŒƒå›´ï¼Œä»è€Œæé«˜äº†æ•ˆç‡ã€‚å¦‚æœå‘ç° Galloping çš„æ•ˆç‡ä½äºäºŒåˆ†æŸ¥æ‰¾ï¼Œåˆ™é€€å‡º Galloping modeã€‚
    // gallopRight å¯»æ‰¾run2çš„ç¬¬ä¸€ä¸ªå…ƒç´ åº”å½“æ’å…¥run1ä¸­å“ªä¸ªä½ç½®ï¼Œç„¶åå°±å¯ä»¥å¿½ç•¥ä¹‹å‰run1çš„å…ƒç´ ï¼ˆéƒ½æ¯”run2çš„ç¬¬ä¸€ä¸ªå…ƒç´ å°ï¼‰
    private static int gallopRight(Comparable<Object> key, Object[] a,
            int base, int len, int hint) {
        assert len > 0 && hint >= 0 && hint < len;

        int ofs = 1;
        int lastOfs = 0;
        // run2çš„ç¬¬ä¸€ä¸ªå€¼keyï¼Œåœ¨Gallopå·¦è¾¹
        if (key.compareTo(a[base + hint]) < 0) {
            // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
            int maxOfs = hint + 1;
            while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) < 0) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1; // ofs = 2 * ofs + 1
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            // Make offsets relative to b
            int tmp = lastOfs;
            lastOfs = hint - ofs;
            ofs = hint - tmp;
        } else { // a[b + hint] <= key // run2çš„ç¬¬ä¸€ä¸ªå€¼keyï¼Œåœ¨Gallop å³è¾¹
            // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
            int maxOfs = len - hint;
            while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) >= 0) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            // Make offsets relative to b
            lastOfs += hint;
            ofs += hint;
        }
        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;

        /*
         * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
         * the right of lastOfs but no farther right than ofs.  Do a binary
         * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
         */
        lastOfs++;
        while (lastOfs < ofs) {
            int m = lastOfs + ((ofs - lastOfs) >>> 1);

            if (key.compareTo(a[base + m]) < 0)
                ofs = m;          // key < a[b + m]
            else
                lastOfs = m + 1;  // a[b + m] <= key
        }
        assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]
        return ofs;
    }

    private static final int  MIN_GALLOP = 7;

    // len1 å°ï¼ŒæŠŠrun1 å¤åˆ¶åˆ°ä¸´æ—¶arrayï¼Œåˆå¹¶
    private void mergeLo(int base1, int len1, int base2, int len2) {
        assert len1 > 0 && len2 > 0 && base1 + len1 == base2;

        // Copy first run into temp array
        Object[] a = this.a; // For performance
        Object[] tmp = ensureCapacity(len1);

        int cursor1 = tmpBase; // Indexes into tmp array
        int cursor2 = base2;   // Indexes int a
        int dest = base1;      // Indexes int a
        System.arraycopy(a, base1, tmp, cursor1, len1);

        // Move first element of second run and deal with degenerate cases
        a[dest++] = a[cursor2++];
        if (--len2 == 0) {
            System.arraycopy(tmp, cursor1, a, dest, len1);
            return;
        }
        if (len1 == 1) {
            System.arraycopy(a, cursor2, a, dest, len2);
            a[dest + len2] = tmp[cursor1]; // Last elt of run 1 to end of merge
            return;
        }

        int minGallop = this.minGallop;  // Use local variable for performance
    outer:
        while (true) {
            int count1 = 0; // Number of times in a row that first run won
            int count2 = 0; // Number of times in a row that second run won

            /*
             * Do the straightforward thing until (if ever) one run starts
             * winning consistently.
             */
            do {
                assert len1 > 1 && len2 > 0;
                if (((Comparable) a[cursor2]).compareTo(tmp[cursor1]) < 0) {
                    a[dest++] = a[cursor2++];
                    count2++;
                    count1 = 0;
                    if (--len2 == 0)
                        break outer;
                } else {
                    a[dest++] = tmp[cursor1++];
                    count1++;
                    count2 = 0;
                    if (--len1 == 1)
                        break outer;
                }
            } while ((count1 | count2) < minGallop);

            /*
             * One run is winning so consistently that galloping may be a
             * huge win. So try that, and continue galloping until (if ever)
             * neither run appears to be winning consistently anymore.
             */
            do {
                assert len1 > 1 && len2 > 0;
                count1 = gallopRight((Comparable) a[cursor2], tmp, cursor1, len1, 0);
                if (count1 != 0) {
                    System.arraycopy(tmp, cursor1, a, dest, count1);
                    dest += count1;
                    cursor1 += count1;
                    len1 -= count1;
                    if (len1 <= 1)  // len1 == 1 || len1 == 0
                        break outer;
                }
                a[dest++] = a[cursor2++];
                if (--len2 == 0)
                    break outer;

                count2 = gallopLeft((Comparable) tmp[cursor1], a, cursor2, len2, 0);
                if (count2 != 0) {
                    System.arraycopy(a, cursor2, a, dest, count2);
                    dest += count2;
                    cursor2 += count2;
                    len2 -= count2;
                    if (len2 == 0)
                        break outer;
                }
                a[dest++] = tmp[cursor1++];
                if (--len1 == 1)
                    break outer;
                minGallop--;
            } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
            if (minGallop < 0)
                minGallop = 0;
            minGallop += 2;  // Penalize for leaving gallop mode
        }  // End of "outer" loop
        this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

        if (len1 == 1) {
            assert len2 > 0;
            System.arraycopy(a, cursor2, a, dest, len2);
            a[dest + len2] = tmp[cursor1]; //  Last elt of run 1 to end of merge
        } else if (len1 == 0) {
            throw new IllegalArgumentException(
                "Comparison method violates its general contract!");
        } else {
            assert len2 == 0;
            assert len1 > 1;
            System.arraycopy(tmp, cursor1, a, dest, len1);
        }
    }

    // base1 = ç¬¬ä¸€æ®µçš„å¼€å§‹ä½ç½®ï¼Œlen1 = ç¬¬ä¸€æ®µçš„é•¿åº¦ï¼Œbase2 = ç¬¬äºŒæ®µçš„å¼€å§‹ä½ç½®ï¼Œlen2 = ç¬¬äºŒæ®µçš„é•¿åº¦
    // len2 å°ï¼ŒæŠŠrun2 å¤åˆ¶åˆ°ä¸´æ—¶arrayï¼Œåˆå¹¶
    private void mergeHi(int base1, int len1, int base2, int len2) {
        assert len1 > 0 && len2 > 0 && base1 + len1 == base2;

        // Copy second run into temp array
        Object[] a = this.a; // For performance
        Object[] tmp = ensureCapacity(len2);
        int tmpBase = this.tmpBase;
        // å­˜æ”¾run2
        System.arraycopy(a, base2, tmp, tmpBase, len2);

        // run1 æ¸¸æ ‡
        int cursor1 = base1 + len1 - 1;  // Indexes into a
        // å¤åˆ¶äº† run2 æ¸¸æ ‡
        int cursor2 = tmpBase + len2 - 1; // Indexes into tmp array
        // run2 æ¸¸æ ‡ï¼Œrun2ç»“æŸä½ç½®
        int dest = base2 + len2 - 1;     // Indexes into a

        // Move last element of first run and deal with degenerate cases
        // cursor1æ˜¯run1çš„ç»“æŸä½ç½®ï¼Œdestæ˜¯run2çš„ç»“æŸä½ç½®ï¼Œrun1çš„ç»“æŸä½ç½®çš„å€¼ä¸€å®šå¤§äºrun2
        a[dest--] = a[cursor1--];
        // len1 = 1ï¼Œrun2éƒ½æ”¾åˆ°dest--å‰é¢
        if (--len1 == 0) {
            System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2);
            return;
        }
        // run2çš„é•¿åº¦ä¸º1ï¼Œé‚£å°±æŠŠä»–æ”¾å…¥åˆ°ç¬¬ä¸€æ®µçš„å‰é¢
        if (len2 == 1) {
            dest -= len1;
            cursor1 -= len1;
            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
            a[dest] = tmp[cursor2];
            return;
        }

        // minGallop = 7ï¼Œæ˜¯é»˜è®¤å€¼
        int minGallop = this.minGallop;  // Use local variable for performance
    outer:
        while (true) {
            // count1å’Œcount2è®°å½•run1ä¸­è¿ç»­æ¯”run2å¤§çš„
            int count1 = 0; // Number of times in a row that first run won
            int count2 = 0; // Number of times in a row that second run won

            /*
             * Do the straightforward thing until (if ever) one run
             * appears to win consistently.
             */
            do {
                assert len1 > 0 && len2 > 1;
                //æ¯”è¾ƒrun1çš„æœ€åä¸€ä¸ªå…ƒç´ å’Œrun2çš„æœ€åä¸€ä¸ªå…ƒç´ çš„å¤§å°
                if (((Comparable) tmp[cursor2]).compareTo(a[cursor1]) < 0) {
                    a[dest--] = a[cursor1--];
                    count1++;
                    count2 = 0;
                    if (--len1 == 0)
                        break outer;
                } else {
                    a[dest--] = tmp[cursor2--];
                    count2++;
                    count1 = 0;
                    if (--len2 == 1)
                        break outer;
                }
            } while ((count1 | count2) < minGallop);

            /*
             * One run is winning so consistently that galloping may be a
             * huge win. So try that, and continue galloping until (if ever)
             * neither run appears to be winning consistently anymore.
             */
            do {
                assert len1 > 0 && len2 > 1;
                count1 = len1 - gallopRight((Comparable) tmp[cursor2], a, base1, len1, len1 - 1);
                if (count1 != 0) {
                    dest -= count1;
                    cursor1 -= count1;
                    len1 -= count1;
                    System.arraycopy(a, cursor1 + 1, a, dest + 1, count1);
                    if (len1 == 0)
                        break outer;
                }
                // æ¯æ¬¡è¿™ä¸ªåˆå¹¶å®Œä¹‹åï¼Œé‡æ–°å»æ‰§è¡ŒgallopRightæˆ–è€…gallopLeftæ–¹æ³•ï¼Œé‡æ–°æŠŠä¸ç”¨åˆå¹¶çš„å‰”é™¤æ‰
                a[dest--] = tmp[cursor2--];
                if (--len2 == 1)
                    break outer;

                count2 = len2 - gallopLeft((Comparable) a[cursor1], tmp, tmpBase, len2, len2 - 1);
                if (count2 != 0) {
                    dest -= count2;
                    cursor2 -= count2;
                    len2 -= count2;
                    System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);
                    if (len2 <= 1)
                        break outer; // len2 == 1 || len2 == 0
                }
                a[dest--] = a[cursor1--];
                if (--len1 == 0)
                    break outer;
                minGallop--;
            } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
            if (minGallop < 0)
                minGallop = 0;
            minGallop += 2;  // Penalize for leaving gallop mode
        }  // End of "outer" loop
        this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

        if (len2 == 1) {
            assert len1 > 0;
            dest -= len1;
            cursor1 -= len1;
            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
            a[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
        } else if (len2 == 0) {
            throw new IllegalArgumentException(
                "Comparison method violates its general contract!");
        } else {
            assert len1 == 0;
            assert len2 > 0;
            System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2);
        }
    }
}
```

åœ¨å½’å¹¶ç®—æ³•ä¸­åˆå¹¶æ˜¯ä¸¤ä¸¤åˆ†åˆ«åˆå¹¶ï¼Œç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªåˆå¹¶ï¼Œç¬¬ä¸‰ä¸ªå’Œç¬¬å››ä¸ªåˆå¹¶ï¼Œç„¶åå†åˆå¹¶è¿™ä¸¤ä¸ªå·²ç»åˆå¹¶çš„åºåˆ—ã€‚ä½†æ˜¯åœ¨Timsortä¸­ï¼Œåˆå¹¶æ˜¯è¿ç»­çš„ï¼Œæ¯æ¬¡è®¡ç®—å‡ºäº†ä¸€ä¸ªrunä¹‹åéƒ½æœ‰å¯èƒ½å¯¼è‡´ä¸€æ¬¡åˆå¹¶ï¼Œè¿™æ ·çš„åˆå¹¶é¡ºåºèƒ½å¤Ÿåœ¨åˆå¹¶çš„åŒæ—¶ä¿è¯ç®—æ³•çš„ç¨³å®šæ€§ã€‚

Timsort ç§°è¿™äº›å·²ç»æ’å¥½åºçš„æ•°æ®å—ä¸º runã€‚åœ¨æ’åºæ—¶ï¼ŒTimsortè¿­ä»£æ•°æ®å…ƒç´ ï¼Œå°†å…¶æ”¾åˆ°ä¸åŒçš„ run é‡Œï¼ŒåŒæ—¶é’ˆå¯¹è¿™äº› run ï¼ŒæŒ‰è§„åˆ™è¿›è¡Œåˆå¹¶è‡³åªå‰©ä¸€ä¸ªï¼Œåˆ™è¿™ä¸ªä»…å‰©çš„ run å³ä¸ºæ’å¥½åºçš„ç»“æœã€‚

![](/images/202203/sort/sort-01.gif)

åˆå¹¶çš„å¹³è¡¡æ€§å°±æ˜¯ä¸ºäº†è®©åˆå¹¶çš„ä¸¤ä¸ªæ•°ç»„çš„å¤§å°å°½é‡æ¥è¿‘ï¼Œæé«˜åˆå¹¶çš„æ•ˆç‡ã€‚æ‰€ä»¥åœ¨åˆå¹¶çš„è¿‡ç¨‹ä¸­éœ€è¦å°½é‡ä¿ç•™è¿™äº›runç”¨äºå‘ç°åæ¥çš„æ¨¡å¼ï¼Œä½†æ˜¯æˆ‘ä»¬åˆæƒ³å°½é‡å¿«çš„åˆå¹¶å†…å­˜å±‚çº§æ¯”è¾ƒé«˜çš„runï¼Œå¹¶ä¸”æ ˆçš„ç©ºé—´æ˜¯æœ‰é™çš„ï¼Œä¸èƒ½æµªè´¹å¤ªå¤šçš„æ ˆç©ºé—´ã€‚é€šè¿‡ä»¥ä¸Šçš„ä¸¤ä¸ªé™åˆ¶ï¼Œå¯ä»¥å°†æ•´ä¸ªæ ˆä»åº•éƒ¨åˆ°é¡¶éƒ¨çš„runçš„å¤§å°å˜æˆä¸¥æ ¼é€’å‡çš„ï¼Œå¹¶ä¸”æ”¶æ•›é€Ÿåº¦å’Œæ–æ³¢é‚£å¥‘æ•°åˆ—ä¸€æ ·ï¼Œè¿™æ ·å°±å¯ä»¥åº”ç”¨æ–æ³¢é‚£å¥‘æ•°åˆ—å’Œçš„å…¬å¼æ ¹æ®æ•°ç»„çš„é•¿åº¦è®¡ç®—å‡ºéœ€è¦çš„æ ˆçš„å¤§å°ï¼Œä¸€å®šæ˜¯æ¯”ğ‘™ğ‘œğ‘”1.618ğ‘è¦å°çš„ï¼Œå…¶ä¸­Næ˜¯æ•°ç»„çš„é•¿åº¦ã€‚

åœ¨æœ€ç†æƒ³çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªæ ˆä»åº•éƒ¨åˆ°é¡¶éƒ¨çš„æ•°å­—åº”è¯¥æ˜¯128ã€64ã€32ã€16ã€8ã€4ã€2ã€2ï¼Œè¿™æ ·ä»æ ˆé¡¶åˆå¹¶åˆ°æ ˆåº•ï¼Œæ¯æ¬¡åˆå¹¶çš„ä¸¤ä¸ªrunçš„é•¿åº¦éƒ½æ˜¯ç›¸ç­‰çš„ï¼Œéƒ½æ˜¯å®Œç¾çš„åˆå¹¶ã€‚

Timsort åˆå¹¶2ä¸ªç›¸é‚»çš„ run éœ€è¦ä¸´æ—¶å­˜å‚¨ç©ºé—²ï¼Œä¸´æ—¶å­˜å‚¨ç©ºé—´çš„å¤§å°æ˜¯2ä¸ª run ä¸­è¾ƒå°çš„ run çš„å¤§å°ã€‚Timsortç®—æ³•å…ˆå°†è¾ƒå°çš„ run å¤åˆ¶åˆ°è¿™ä¸ªä¸´æ—¶å­˜å‚¨ç©ºé—´ï¼Œç„¶åç”¨åŸå…ˆå­˜å‚¨è¿™2ä¸ª run çš„ç©ºé—´æ¥å­˜å‚¨åˆå¹¶åçš„ runã€‚

gallopRight å’Œ gallopLeftä¹‹åéœ€è¦åˆå¹¶çš„éƒ¨åˆ†

![](/images/202203/sort/srot-04.png)

åŠ é€Ÿåˆå¹¶

åœ¨å½’å¹¶æ’åºç®—æ³•ä¸­åˆå¹¶ä¸¤ä¸ªæ•°ç»„å°±æ˜¯ä¸€ä¸€æ¯”è¾ƒæ¯ä¸ªå…ƒç´ ï¼ŒæŠŠè¾ƒå°çš„æ”¾åˆ°ç›¸åº”çš„ä½ç½®ï¼Œç„¶åæ¯”è¾ƒä¸‹ä¸€ä¸ªï¼Œè¿™æ ·æœ‰ä¸€ä¸ªç¼ºç‚¹å°±æ˜¯å¦‚æœAä¸­å¦‚æœæœ‰å¤§é‡çš„å…ƒç´ A[i...j]æ˜¯å°äºBä¸­æŸä¸€ä¸ªå…ƒç´ B[k]çš„ï¼Œç¨‹åºä»ç„¶ä¼šæŒç»­çš„æ¯”è¾ƒA[i...j]ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ å’ŒB[k]ï¼Œå¢åŠ åˆå¹¶è¿‡ç¨‹ä¸­çš„æ—¶é—´æ¶ˆè€—ã€‚

ä¸ºäº†ä¼˜åŒ–åˆå¹¶çš„è¿‡ç¨‹ï¼ŒTimè®¾å®šäº†ä¸€ä¸ªé˜ˆå€¼MIN_GALLOPï¼Œå¦‚æœAä¸­è¿ç»­MIN_GALLOPä¸ªå…ƒç´ æ¯”Bä¸­æŸä¸€ä¸ªå…ƒç´ è¦å°ï¼Œé‚£ä¹ˆå°±è¿›å…¥GALLOPæ¨¡å¼ï¼Œåä¹‹äº¦ç„¶ã€‚é»˜è®¤çš„MIN_GALLOPå€¼æ˜¯7ã€‚

åœ¨GALLOPæ¨¡å¼ä¸­ï¼Œé¦–å…ˆé€šè¿‡äºŒåˆ†æœç´¢æ‰¾åˆ°A[0]åœ¨Bä¸­çš„ä½ç½®i0ï¼ŒæŠŠBä¸­i0ä¹‹å‰çš„å…ƒç´ ç›´æ¥æ”¾å…¥åˆå¹¶çš„ç©ºé—´ä¸­ï¼Œç„¶åå†åœ¨Aä¸­æ‰¾åˆ°B[i0]æ‰€åœ¨çš„ä½ç½®j0ï¼ŒæŠŠAä¸­j0ä¹‹å‰çš„å…ƒç´ ç›´æ¥æ”¾å…¥åˆå¹¶ç©ºé—´ä¸­ï¼Œå¦‚æ­¤å¾ªç¯ç›´è‡³åœ¨Aå’ŒBä¸­æ¯æ¬¡æ‰¾åˆ°çš„æ–°çš„ä½ç½®å’ŒåŸä½ç½®çš„å·®å€¼æ˜¯å°äºMIN_GALLOPçš„ï¼Œè¿™æ‰åœæ­¢ç„¶åç»§ç»­è¿›è¡Œä¸€å¯¹ä¸€çš„æ¯”è¾ƒã€‚

![](/images/202203/sort/sort-02.gif)

## Python

ç‰ˆæœ¬ 3.10.2

å†…éƒ¨å®ç°æœºåˆ¶ä¸ºï¼šTimsortã€æ’å…¥æ’åº

Javaæ˜¯å‚è€ƒçš„Pythonçš„ï¼ŒTimSort åŸç†ä¸€æ ·

Objects/listobject.c

```
int
PyList_Sort(PyObject *v)
{
    if (v == NULL || !PyList_Check(v)) {
        PyErr_BadInternalCall();
        return -1;
    }
    v = list_sort_impl((PyListObject *)v, NULL, 0);
    if (v == NULL)
        return -1;
    Py_DECREF(v);
    return 0;
}

list_sort_impl(PyListObject *self, PyObject *keyfunc, int reverse)
/*[clinic end generated code: output=57b9f9c5e23fbe42 input=cb56cd179a713060]*/
{
    MergeState ms;
    Py_ssize_t nremaining;
    Py_ssize_t minrun;
    sortslice lo;
    Py_ssize_t saved_ob_size, saved_allocated;
    PyObject **saved_ob_item;
    PyObject **final_ob_item;
    PyObject *result = NULL;            /* guilty until proved innocent */
    Py_ssize_t i;
    PyObject **keys;

    ...


    /* The pre-sort check: here's where we decide which compare function to use.
     * How much optimization is safe? We test for homogeneity with respect to
     * several properties that are expensive to check at compare-time, and
     * set ms appropriately. */
    ...

    merge_init(&ms, saved_ob_size, keys != NULL);

    nremaining = saved_ob_size;
    if (nremaining < 2)
        goto succeed;

    /* Reverse sort stability achieved by initially reversing the list,
    applying a stable forward sort, then reversing the final result. */
    if (reverse) {
        if (keys != NULL)
            reverse_slice(&keys[0], &keys[saved_ob_size]);
        reverse_slice(&saved_ob_item[0], &saved_ob_item[saved_ob_size]);
    }

    /* March over the array once, left to right, finding natural runs,
     * and extending short natural runs to minrun elements.
     */
    // TimSort è®¡ç®— minRunçš„å€¼ï¼Œæœ€å°åˆ†ç‰‡é•¿åº¦ 32 <= k <= 64
    minrun = merge_compute_minrun(nremaining);
    do {
        int descending;
        Py_ssize_t n;

        /* Identify next run. */
        n = count_run(&ms, lo.keys, lo.keys + nremaining, &descending);
        if (n < 0)
            goto fail;
        if (descending)
            reverse_sortslice(&lo, n);
        /* If short, extend to min(minrun, nremaining). */
        // åŸå§‹çš„runå°äºminrunçš„é•¿åº¦ï¼Œç”¨äºŒåˆ†æ’å…¥æ’åºæ‰©å……runï¼Œç›´åˆ°è¾¾åˆ°æ¡ä»¶
        if (n < minrun) {
            const Py_ssize_t force = nremaining <= minrun ?
                              nremaining : minrun;
            if (binarysort(&ms, lo, lo.keys + force, lo.keys + n) < 0)
                goto fail;
            n = force;
        }
        /* Push run onto pending-runs stack, and maybe merge. */
        assert(ms.n < MAX_MERGE_PENDING);
        // å…¥æ ˆ
        ms.pending[ms.n].base = lo;
        ms.pending[ms.n].len = n;
        ++ms.n;
        if (merge_collapse(&ms) < 0)
            goto fail;
        /* Advance to find next run. */
        sortslice_advance(&lo, n);
        nremaining -= n;
    } while (nremaining);

    if (merge_force_collapse(&ms) < 0)
        goto fail;
    assert(ms.n == 1);
    assert(keys == NULL
           ? ms.pending[0].base.keys == saved_ob_item
           : ms.pending[0].base.keys == &keys[0]);
    assert(ms.pending[0].len == saved_ob_size);
    lo = ms.pending[0].base;

succeed:
    result = Py_None;
fail:
    ...
    result = NULL;
}
#undef IFLT
#undef ISLT

/* Compute a good value for the minimum run length; natural runs shorter
 * than this are boosted artificially via binary insertion.
 *
 * If n < 64, return n (it's too small to bother with fancy stuff).
 * Else if n is an exact power of 2, return 32.
 * Else return an int k, 32 <= k <= 64, such that n/k is close to, but
 * strictly less than, an exact power of 2.
 *
 * See listsort.txt for more info.
 */
static Py_ssize_t
merge_compute_minrun(Py_ssize_t n)
{
    Py_ssize_t r = 0;           /* becomes 1 if any 1 bits are shifted off */

    assert(n >= 0);
    while (n >= 64) {
        r |= n & 1;
        n >>= 1;
    }
    return n + r;
}

/* Examine the stack of runs waiting to be merged, merging adjacent runs
 * until the stack invariants are re-established:
 *
 * 1. len[-3] > len[-2] + len[-1]
 * 2. len[-2] > len[-1]
 *
 * See listsort.txt for more info.
 *
 * Returns 0 on success, -1 on error.
 */
static int
merge_collapse(MergeState *ms)
{
    struct s_slice *p = ms->pending;

    assert(ms);
    while (ms->n > 1) {
        Py_ssize_t n = ms->n - 2;
        if ((n > 0 && p[n-1].len <= p[n].len + p[n+1].len) ||
            (n > 1 && p[n-2].len <= p[n-1].len + p[n].len)) {
            if (p[n-1].len < p[n+1].len)
                --n;
            if (merge_at(ms, n) < 0)
                return -1;
        }
        else if (p[n].len <= p[n+1].len) {
            if (merge_at(ms, n) < 0)
                return -1;
        }
        else
            break;
    }
    return 0;
}

merge_at(MergeState *ms, Py_ssize_t i)
{
    sortslice ssa, ssb;
    Py_ssize_t na, nb;
    Py_ssize_t k;
    ssa = ms->pending[i].base;
    na = ms->pending[i].len;
    ssb = ms->pending[i+1].base;
    nb = ms->pending[i+1].len;
    assert(na > 0 && nb > 0);
    assert(ssa.keys + na == ssb.keys);

    /* Record the length of the combined runs; if i is the 3rd-last
     * run now, also slide over the last run (which isn't involved
     * in this merge).  The current run i+1 goes away in any case.
     */
    ms->pending[i].len = na + nb;
    if (i == ms->n - 3)
        ms->pending[i+1] = ms->pending[i+2];
    --ms->n;

    /* Where does b start in a?  Elements in a before that can be
     * ignored (already in place).
     */
    k = gallop_right(ms, *ssb.keys, ssa.keys, na, 0);
    if (k < 0)
        return -1;
    sortslice_advance(&ssa, k);
    na -= k;
    if (na == 0)
        return 0;

    /* Where does a end in b?  Elements in b after that can be
     * ignored (already in place).
     */
    nb = gallop_left(ms, ssa.keys[na-1], ssb.keys, nb, nb-1);
    if (nb <= 0)
        return nb;

    /* Merge what remains of the runs, using a temp array with
     * min(na, nb) elements.
     */
    if (na <= nb)
        return merge_lo(ms, ssa, na, ssb, nb);
    else
        return merge_hi(ms, ssa, na, ssb, nb);
}
```

## Golang

sort/sort.go

å†…éƒ¨å®ç°æœºåˆ¶ä¸ºï¼šå¿«é€Ÿæ’åºã€å †æ’åºã€å¸Œå°”æ’åºã€æ’å…¥æ’åº

ç®—æ³•ç¨³å®šæ€§ï¼šä¸ç¨³å®š

- slices <= 12ï¼Œä½¿ç”¨ gap = 6 çš„å¸Œå°”æ’åº
- slices > 12ï¼Œä½¿ç”¨å¿«é€Ÿæ’åºï¼Œæ·±åº¦ä¸º0çš„æ—¶å€™ä½¿ç”¨å †æ’åº

```
Len() int: è¿”å›ä¼ å…¥æ•°æ®çš„æ€»æ•°
Less(i, j int) bool: è¿”å›æ•°ç»„ä¸­ä¸‹æ ‡ä¸ºiçš„æ•°æ®æ˜¯å¦å°äºä¸‹æ ‡ä¸ºjçš„æ•°æ®
Swap(i, j int): è¡¨ç¤ºæ‰§è¡Œäº¤æ¢æ•°ç»„ä¸­ä¸‹æ ‡ä¸ºiçš„æ•°æ®å’Œä¸‹æ ‡ä¸ºjçš„æ•°æ®
```

è°ƒç”¨sortåŒ…çš„æ’åºï¼Œéœ€è¦å®ç°æ’åºæ¥å£

```
type Interface interface {
	// Len is the number of elements in the collection.
	Len() int
	// Less reports whether the element with
	// index i should sort before the element with index j.
	Less(i, j int) bool
	// Swap swaps the elements with indexes i and j.
	Swap(i, j int)
}
```

Sortæ–¹æ³•

```
func Sort(data Interface) {
	n := data.Len()
	quickSort(data, 0, n, maxDepth(n))
}

func quickSort(data Interface, a, b, maxDepth int) {
	for b-a > 12 { // Use ShellSort for slices <= 12 elements
		if maxDepth == 0 {
			heapSort(data, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivot(data, a, b)
		// Avoiding recursion on the larger subproblem guarantees
		// a stack depth of at most lg(b-a).
		if mlo-a < b-mhi {
			quickSort(data, a, mlo, maxDepth)
			a = mhi // i.e., quickSort(data, mhi, b)
		} else {
			quickSort(data, mhi, b, maxDepth)
			b = mlo // i.e., quickSort(data, a, mlo)
		}
	}
	if b-a > 1 {
		// Do ShellSort pass with gap 6
		// It could be written in this simplified form cause b-a <= 12
		for i := a + 6; i < b; i++ {
			if data.Less(i, i-6) {
				data.Swap(i, i-6)
			}
		}
		insertionSort(data, a, b)
	}
}

// è¿”å›å€¼ 2*ceil(lg(n+1))ï¼Œ20 è¿”å› 10
// maxDepth returns a threshold at which quicksort should switch
// to heapsort. It returns 2*ceil(lg(n+1)).
func maxDepth(n int) int {
	var depth int
	for i := n; i > 0; i >>= 1 {
		depth++
	}
	return depth * 2
}

// å»ºç«‹ä¸€ä¸ªå¤§é¡¶å †ï¼Œå°†æ ¹èŠ‚ç‚¹äº¤æ¢åˆ°å †æ•°æ®çš„æœ€åï¼Œç”¨å‰©ä¸‹çš„å…ƒç´ ç»§ç»­å»ºç«‹å¤§é¡¶å †ï¼Œç„¶åä¸æ–­é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´è‡³æœ€åä¸€ä¸ªå…ƒç´ 
func heapSort(data Interface, a, b int) {
	first := a
	lo := 0
	hi := b - a

	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDown(data, i, hi, first)
	}

	// Pop elements, largest first, into end of data.
	for i := hi - 1; i >= 0; i-- {
		data.Swap(first, first+i)
		siftDown(data, lo, i, first)
	}
}

func siftDown(data Interface, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
        // ä¿è¯äº¤æ¢çš„æ˜¯æœ€å¤§çš„å­èŠ‚ç‚¹
		if child+1 < hi && data.Less(first+child, first+child+1) {
			child++
		}
        // çˆ¶èŠ‚ç‚¹å·²ç»æ˜¯æœ€å¤§äº†ï¼Œä¸éœ€è¦äº¤æ¢
		if !data.Less(first+root, first+child) {
			return
		}
        // äº¤æ¢çˆ¶å­èŠ‚ç‚¹
		data.Swap(first+root, first+child)
		root = child
	}
}

func doPivot(data Interface, lo, hi int) (midlo, midhi int) {
    // é¦–å…ˆç”¨ä½è¿ç®—çš„æ–¹å¼æ±‚ä¸­é—´ç‚¹ï¼Œé˜²æ­¢æº¢å‡º
	m := int(uint(lo+hi) >> 1) // Written like this to avoid integer overflow.
	if hi-lo > 40 {
        //  å¤šæ•°å–ä¸­
		// Tukey's ``Ninther,'' median of three medians of three.
		s := (hi - lo) / 8
		medianOfThree(data, lo, lo+s, lo+2*s)
		medianOfThree(data, m, m-s, m+s)
		medianOfThree(data, hi-1, hi-1-s, hi-1-2*s)
	}
	medianOfThree(data, lo, m, hi-1)

	// Invariants are:
	//	data[lo] = pivot (set up by ChoosePivot)
	//	data[lo < i < a] < pivot
	//	data[a <= i < b] <= pivot
	//	data[b <= i < c] unexamined
	//	data[c <= i < hi-1] > pivot
	//	data[hi-1] >= pivot
	pivot := lo
	a, c := lo+1, hi-1

	for ; a < c && data.Less(a, pivot); a++ {
	}
	b := a
	for {
		for ; b < c && !data.Less(pivot, b); b++ { // data[b] <= pivot
		}
		for ; b < c && data.Less(pivot, c-1); c-- { // data[c-1] > pivot
		}
		if b >= c {
			break
		}
		// data[b] > pivot; data[c-1] <= pivot
		data.Swap(b, c-1)
		b++
		c--
	}
	// If hi-c<3 then there are duplicates (by property of median of nine).
	// Let's be a bit more conservative, and set border to 5.
	protect := hi-c < 5
	if !protect && hi-c < (hi-lo)/4 {
		// Lets test some points for equality to pivot
		dups := 0
		if !data.Less(pivot, hi-1) { // data[hi-1] = pivot
			data.Swap(c, hi-1)
			c++
			dups++
		}
		if !data.Less(b-1, pivot) { // data[b-1] = pivot
			b--
			dups++
		}
		// m-lo = (hi-lo)/2 > 6
		// b-lo > (hi-lo)*3/4-1 > 8
		// ==> m < b ==> data[m] <= pivot
		if !data.Less(m, pivot) { // data[m] = pivot
			data.Swap(m, b-1)
			b--
			dups++
		}
		// if at least 2 points are equal to pivot, assume skewed distribution
		protect = dups > 1
	}
	if protect {
		// Protect against a lot of duplicates
		// Add invariant:
		//	data[a <= i < b] unexamined
		//	data[b <= i < c] = pivot
		for {
			for ; a < b && !data.Less(b-1, pivot); b-- { // data[b] == pivot
			}
			for ; a < b && data.Less(a, pivot); a++ { // data[a] < pivot
			}
			if a >= b {
				break
			}
			// data[a] == pivot; data[b-1] < pivot
			data.Swap(a, b-1)
			a++
			b--
		}
	}
	// Swap pivot into middle
	data.Swap(pivot, b-1)
	return b - 1, c
}

// Insertion sort æ’å…¥æ’åº
func insertionSort(data Interface, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && data.Less(j, j-1); j-- {
			data.Swap(j, j-1)
		}
	}
}
```

## èµ„æ–™

- [PHP sort æºç ](https://schaepher.github.io/2020/03/30/php-sort/)
- [å¿«é€Ÿæ’åº(ä¸‰ç§ç®—æ³•å®ç°å’Œéé€’å½’å®ç°)](https://blog.csdn.net/qq_36528114/article/details/78667034)
- [Javaä¸­Arrays.sortæºä»£ç è§£æ](https://blog.csdn.net/zuochao_2013/article/details/79513962) 
- [TimSort](https://www.cnblogs.com/sunshuyi/p/12680918.html)
- [TimSortçš„å®ç°](https://mp.weixin.qq.com/s?__biz=MzI2MTY0OTg2Nw==&mid=2247483816&idx=1&sn=079af3d70efcb68efa7400f09decb59c&chksm=ea56650cdd21ec1ace7c8fd168d62feb636e4b32f9a4d90329fe479489d8e7a70e612df8920b&token=2074049324&lang=zh_CN#rd)
- [Golangæºç åˆ†æä¹‹sort](https://studygolang.com/articles/26653?fr=sidebar)
- [ä»Golangçš„æ’åºç®—æ³•çœ‹å¦‚ä½•æ¥ä¼˜åŒ–æ’åº](https://zhuanlan.zhihu.com/p/97965012)